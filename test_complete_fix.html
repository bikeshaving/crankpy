<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Complete Fix Test</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
    
    <script>
        window.crankPyCreateIterable = function(items) {
            return {
                [Symbol.iterator]: function() {
                    let index = 0;
                    return {
                        next: function() {
                            if (index < items.length) {
                                return { value: items[index++], done: false };
                            } else {
                                return { value: undefined, done: true };
                            }
                        }
                    };
                }
            };
        };
    </script>
</head>
<body>
    <div id="test-output"></div>
    
    <mpy-config></mpy-config>
    
    <script type="mpy">
import sys
from js import document, Object, window
from pyscript.ffi import create_proxy, to_js

output_div = document.getElementById("test-output")

def log_result(message):
    output_div.innerHTML += f"<div>{message}</div>"

log_result(f"Python implementation: {sys.implementation.name}")

try:
    log_result("Testing complete fix from scratch...")
    
    # Step 1: Recreate fixed Context class
    class FixedContext:
        def __init__(self, js_context):
            self._js_context = js_context
        
        def __iter__(self):
            # Use generator instead of class-based iterator (THE FIX!)
            def context_generator():
                while True:
                    if hasattr(self._js_context, 'props'):
                        props = self._js_context.props
                        yield dict(props) if props else {}
                    else:
                        yield {}
            return context_generator()
    
    log_result("‚úÖ FixedContext defined")
    
    # Step 2: Recreate generator wrapping function
    def create_js_iterable(generator_or_value):
        if hasattr(generator_or_value, 'send') or hasattr(generator_or_value, '__next__'):
            items = list(generator_or_value)
        else:
            items = [generator_or_value]
        
        js_items = to_js(items)
        return window.crankPyCreateIterable(js_items)
    
    log_result("‚úÖ create_js_iterable defined")
    
    # Step 3: Recreate component decorator
    def fixed_component(func):
        def wrapper(props, ctx):
            wrapped_ctx = FixedContext(ctx)
            
            # Call function with proper parameter count
            try:
                result = func(wrapped_ctx)
            except TypeError:
                # Try with no parameters
                result = func()
            
            # Wrap result if it's a generator
            if (sys.implementation.name == 'micropython' and 
                (hasattr(result, 'send') or hasattr(result, '__next__'))):
                return create_js_iterable(result)
            return result
        
        return create_proxy(wrapper)
    
    log_result("‚úÖ fixed_component decorator defined")
    
    # Step 4: Test the complete solution
    @fixed_component
    def TestComponent(ctx):
        log_result("  TestComponent called")
        for props in ctx:
            log_result("  TestComponent: iteration works!")
            yield "Test result!"
            break
    
    log_result("‚úÖ TestComponent defined with fixed decorator")
    
    # Step 5: Test calling the component
    mock_props = Object.new()
    mock_ctx = Object.new()
    mock_ctx.props = Object.new()
    
    try:
        log_result("üöÄ Testing final component call...")
        result = TestComponent(mock_props, mock_ctx)
        log_result(f"‚úÖ Component call succeeded: {type(result)}")
        
        # Test if result has Symbol.iterator
        from js import Symbol
        iterator_symbol = Symbol.iterator
        iterator_method = result[iterator_symbol]
        log_result(f"‚úÖ Result has Symbol.iterator: {iterator_method is not None}")
        
        # Test JavaScript iteration
        test_code = f"""
        (function(iterable) {{
            try {{
                const results = [];
                for (const item of iterable) {{
                    results.push(item);
                }}
                return {{ success: true, results: results }};
            }} catch (e) {{
                return {{ success: false, error: e.message }};
            }}
        }})
        """
        
        from js import eval as js_eval
        test_func = js_eval(test_code)
        test_result = test_func(result)
        
        if test_result.success:
            log_result(f"üéâ COMPLETE SUCCESS! Results: {test_result.results}")
            log_result("‚úÖ MicroPython components with generators now work!")
        else:
            log_result(f"‚ùå JavaScript iteration failed: {test_result.error}")
        
    except Exception as e:
        log_result(f"‚ùå Component call failed: {e}")
        
except Exception as e:
    log_result(f"‚ùå Test failed: {e}")

log_result("Complete fix test completed")
    </script>
</body>
</html>