<\!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Component Decorator Debug</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
</head>
<body>
    <div id="test-output"></div>
    
    <mpy-config>
        {
            "files": {
                "./crank/__init__.py": "crank/__init__.py",
                "./crank/dom.py": "crank/dom.py",
                "./crank/typing_stub.py": "crank/typing_stub.py"
            },
            "js_modules": {
                "main": {
                    "https://esm.run/@b9g/crank@0.7.1/crank.js": "crank_core",
                    "https://esm.run/@b9g/crank@0.7.1/dom.js": "crank_dom"
                }
            }
        }
    </mpy-config>
    
    <script type="mpy">
import sys
from js import document, Symbol, Object, console

output_div = document.getElementById("test-output")

def log_result(message):
    output_div.innerHTML += f"<div>{message}</div>"
    console.log(message)

log_result(f"Python implementation: {sys.implementation.name}")

try:
    from crank import createElement, Context, SymbolIteratorWrapper
    
    log_result("üîç Component Decorator Debug - Isolating the bug...")
    
    # Step 1: Test what happens in wrap_result function
    log_result("=== Step 1: Testing wrap_result logic ===")
    
    def test_generator():
        log_result("test_generator called")
        yield createElement("div", None, "Test")
    
    # Simulate what happens in the component decorator
    def simulate_wrap_result(result):
        """Simulate the wrap_result function from component decorator"""
        log_result(f"wrap_result called with: {type(result)}")
        
        # Check if already wrapped to prevent double-wrapping
        if hasattr(result, '_is_symbol_iterator_wrapped'):
            log_result("Already wrapped, returning as-is")
            return result
        
        # Check if we're in MicroPython and result needs wrapping
        if (sys.implementation.name == 'micropython' and 
            (hasattr(result, 'send') or hasattr(result, '__next__') or 
             hasattr(result, 'asend') or hasattr(result, '__anext__'))):
            log_result("MicroPython generator detected, applying SymbolIteratorWrapper")
            wrapped = SymbolIteratorWrapper(result)
            log_result(f"Created wrapper: {type(wrapped)}")
            return wrapped
            
        log_result("No wrapping needed")
        return result
    
    # Test wrap_result with generator
    try:
        gen = test_generator()
        log_result(f"Created generator: {type(gen)}")
        
        wrapped_result = simulate_wrap_result(gen)
        log_result(f"‚úÖ wrap_result succeeded: {type(wrapped_result)}")
        
        # Test if the wrapped result works
        try:
            iterator_func = wrapped_result[Symbol.iterator]
            iterator = iterator_func()
            item = iterator.next()
            log_result(f"‚úÖ Wrapped result iteration: {item}")
        except Exception as iter_e:
            log_result(f"‚ùå Wrapped result iteration failed: {iter_e}")
            
    except Exception as e:
        log_result(f"‚ùå wrap_result simulation failed: {e}")
    
    log_result("=== Step 2: Testing component wrapper function ===")
    
    # Manually simulate the component decorator wrapper
    def manual_component_wrapper(original_func):
        """Manually simulate the component decorator wrapper"""
        
        def wrapper(props, ctx):
            log_result(f"Component wrapper called with props: {type(props)}, ctx: {type(ctx)}")
            
            # Wrap the JS context with our Python Context wrapper
            wrapped_ctx = Context(ctx)
            log_result(f"Created wrapped context: {type(wrapped_ctx)}")
            
            # Convert props to Python dict
            if hasattr(props, 'to_py'):
                python_props = props.to_py() if props else {}
            else:
                # MicroPython: Use safe conversion to avoid dict() iteration bug
                if props:
                    try:
                        from js import eval as js_eval
                        js_code = """
                        (function(jsObj) {
                            if (!jsObj) return {};
                            const result = {};
                            for (const key in jsObj) {
                                if (jsObj.hasOwnProperty(key)) {
                                    result[key] = jsObj[key];
                                }
                            }
                            return result;
                        })
                        """
                        convert_obj = js_eval(js_code)
                        js_dict = convert_obj(props)
                        if hasattr(js_dict, 'to_py'):
                            python_props = js_dict.to_py()
                        else:
                            python_props = {}
                    except Exception:
                        python_props = {}
                else:
                    python_props = {}
            
            log_result(f"Converted props: {python_props}")
            
            # Call the original function with 1 parameter (ctx only)
            log_result("Calling original function...")
            try:
                result = original_func(wrapped_ctx)
                log_result(f"Original function returned: {type(result)}")
                
                # Apply wrap_result
                log_result("Applying wrap_result...")
                wrapped_result = simulate_wrap_result(result)
                log_result(f"wrap_result returned: {type(wrapped_result)}")
                
                return wrapped_result
                
            except Exception as call_e:
                log_result(f"‚ùå Function call failed: {call_e}")
                raise
        
        from pyscript.ffi import create_proxy
        return create_proxy(wrapper)
    
    # Test manual component wrapper
    def test_component_func(ctx):
        log_result("test_component_func called")
        
        def comp_generator():
            log_result("comp_generator started")
            yield createElement("div", None, "Component test")
        
        return comp_generator()
    
    try:
        log_result("Creating manual component wrapper...")
        manual_wrapped = manual_component_wrapper(test_component_func)
        log_result(f"Manual wrapper created: {type(manual_wrapped)}")
        
        # Test calling the manual wrapper
        mock_props = Object.new()
        mock_ctx_js = Object.new()
        mock_ctx_js.props = Object.new()
        
        log_result("Calling manual wrapper...")
        manual_result = manual_wrapped(mock_props, mock_ctx_js)
        log_result(f"‚úÖ Manual wrapper call succeeded: {type(manual_result)}")
        
    except Exception as e:
        log_result(f"‚ùå Manual wrapper test failed: {e}")
    
except Exception as e:
    log_result(f"‚ùå Test setup failed: {e}")

log_result("Component decorator debug completed")
    </script>
</body>
</html>
EOF < /dev/null