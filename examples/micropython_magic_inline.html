<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MicroPython Magic Syntax Inline</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <script>
        // Mock createElement for testing
        window.mock_createElement = function(tag, props, ...children) {
            return {
                tag: tag,
                props: props, 
                children: children,
                toString: function() { return `<${tag}>`; },
                as_object_map: function() {
                    return new Proxy(this, {
                        get(target, prop) { return target[prop]; },
                        set(target, prop, value) { target[prop] = value; return true; }
                    });
                }
            };
        };
    </script>
</head>
<body>
    <h1>MicroPython: Magic Syntax Inline Test</h1>
    <div id="output">Loading...</div>

    <py-config type="json">
        {
            "type": "micropython"
        }
    </py-config>

    <py-script>
        import js
        from pyodide.ffi import to_js, create_proxy  # Use what's available
        
        output = js.document.getElementById("output")
        output.innerHTML = "Testing magic syntax implementation inline<br><br>"
        
        def log(msg):
            output.innerHTML += msg + "<br>"
        
        # Mock our createElement
        createElement = js.mock_createElement
        
        # Global variable to track if we've patched the as_object_map type yet
        _as_object_map_type_patched = False
        
        def _patch_as_object_map_type():
            """Patch the dynamic type created by as_object_map() to support chainable elements"""
            global _as_object_map_type_patched
            if _as_object_map_type_patched:
                return
            
            # Create a dummy element to get the as_object_map type
            dummy_elem = createElement('div', None)
            if hasattr(dummy_elem, 'as_object_map'):
                mapped = dummy_elem.as_object_map()
                mapped_type = type(mapped)
                
                # Create our chainable __getitem__
                def chainable_getitem(self, children):
                    # Check if this is a chainable element with our custom properties
                    if hasattr(self, '_crank_tag') and hasattr(self, '_crank_props'):
                        # This is our chainable element - create element with children
                        if not isinstance(children, (list, tuple)):
                            children = [children]
                        js_children = [to_js(child) if not isinstance(child, str) else child for child in children]
                        js_props = to_js(self._crank_props) if self._crank_props else None
                        return createElement(self._crank_tag, js_props, *js_children)
                    else:
                        # Regular as_object_map behavior - try property access
                        try:
                            return getattr(self, children)
                        except AttributeError:
                            raise KeyError(children)
                
                # Patch the type
                mapped_type.__getitem__ = chainable_getitem
                _as_object_map_type_patched = True
                log("‚úÖ Dynamic type patching successful")
                return True
            return False
        
        # Test our magic syntax approach
        try:
            # Step 1: Patch the type
            if _patch_as_object_map_type():
                log("‚úÖ Type patching works")
                
                # Step 2: Create chainable element (simulates h.div(className="test"))
                element = createElement('div', {'className': 'test'})
                
                if hasattr(element, 'as_object_map'):
                    chainable = element.as_object_map()
                    
                    # Mark this as a chainable element
                    chainable._crank_tag = 'div'
                    chainable._crank_props = {'className': 'test'}
                    
                    log("‚úÖ Chainable element created")
                    
                    # Step 3: Test the magic syntax!
                    try:
                        result = chainable["Hello World"]
                        log("üéâ Magic syntax works!")
                        log(f"Result: {result}")
                        log(f"Result tag: {result.tag}")
                        log(f"Result props: {result.props}")
                        log(f"Result children: {result.children}")
                        
                        log("<br>‚úÖ h.div(className='test')['Hello World'] would work on MicroPython!")
                        
                    except Exception as e:
                        log(f"‚ùå Magic syntax failed: {e}")
                        import traceback
                        log(f"Traceback: {traceback.format_exc()}")
                        
                else:
                    log("‚ùå No as_object_map on element")
            else:
                log("‚ùå Type patching failed")
                
        except Exception as e:
            log(f"‚ùå Test failed: {e}")
            import traceback
            log(f"Traceback: {traceback.format_exc()}")
            
        log("<br>=== CONCLUSION ===")
        log("If this works, our magic syntax implementation")
        log("just needs the import changed from pyscript.ffi to pyodide.ffi")
    </py-script>
</body>
</html>