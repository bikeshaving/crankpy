<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MicroPython Bug Workarounds - Working Solutions</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
</head>
<body>
    <h1>Working Workarounds for MicroPython Bugs</h1>
    <div id="output"></div>
    
    <mpy-config>
        {}
    </mpy-config>
    
    <script type="mpy">
import sys
from js import document, Object, Symbol, console

output_div = document.getElementById("output")

def log(message):
    output_div.innerHTML += f"<div>{message}</div>"
    console.log(message)

log(f"Python implementation: {sys.implementation.name}")

# Workaround 1: Avoid dir() on JsProxy, use JavaScript enumeration instead
def safe_get_js_attributes(js_obj):
    """Safely enumerate JavaScript object properties without triggering dir() bug"""
    try:
        from js import eval as js_eval
        js_code = """
        (function(jsObj) {
            const props = [];
            for (const key in jsObj) {
                if (typeof key === 'string') {
                    props.push(key);
                }
            }
            return props;
        })
        """
        get_props = js_eval(js_code)
        attrs = get_props(js_obj)
        
        # Convert to Python list if needed
        if hasattr(attrs, 'to_py'):
            return attrs.to_py()
        elif hasattr(attrs, '__iter__'):
            return list(attrs)
        else:
            return []
    except Exception:
        return []

# Workaround 2: Avoid dict() on JsProxy, use JavaScript conversion instead
def safe_js_to_dict(js_obj):
    """Safely convert JavaScript object to Python dict without triggering dict() bug"""
    try:
        from js import eval as js_eval
        js_code = """
        (function(jsObj) {
            if (!jsObj) return {};
            const result = {};
            for (const key in jsObj) {
                if (jsObj.hasOwnProperty(key)) {
                    result[key] = jsObj[key];
                }
            }
            return result;
        })
        """
        convert_obj = js_eval(js_code)
        js_dict = convert_obj(js_obj)
        
        # Convert to Python dict safely
        if hasattr(js_dict, 'to_py'):
            return js_dict.to_py()
        else:
            return {}
    except Exception:
        return {}

# Workaround 3: Symbol.iterator wrapper that uses JavaScript comparison
class SymbolIteratorWrapper:
    """Make Python generators compatible with JavaScript Symbol.iterator"""
    
    def __init__(self, python_generator):
        self.python_generator = python_generator
        self._is_symbol_iterator_wrapped = True
    
    def __getitem__(self, key):
        """Handle Symbol.iterator access using JavaScript comparison"""
        from js import eval as js_eval
        
        js_code = """
        (function(pythonKey, pythonGen) {
            if (pythonKey === Symbol.iterator) {
                return function() {
                    return {
                        next: function() {
                            try {
                                const value = pythonGen.__next__();
                                return { value: value, done: false };
                            } catch (e) {
                                return { value: undefined, done: true };
                            }
                        }
                    };
                };
            }
            throw new Error('SymbolIteratorWrapper: Not Symbol.iterator');
        })
        """
        
        try:
            js_func = js_eval(js_code)
            return js_func(key, self.python_generator)
        except Exception:
            raise KeyError(f"SymbolIteratorWrapper: Unsupported key {key}")
    
    def __iter__(self):
        return self
    
    def __next__(self):
        return next(self.python_generator)

# Test the workarounds
log("=== Testing Workarounds ===")

# Test 1: Safe attribute enumeration
js_obj = Object.new()
js_obj.prop1 = "value1" 
js_obj.prop2 = "value2"

log("Test 1: Safe attribute enumeration")
try:
    attrs = safe_get_js_attributes(js_obj)
    log(f"✅ Safe enumeration: {attrs}")
except Exception as e:
    log(f"❌ Safe enumeration failed: {e}")

# Test 2: Safe dict conversion
log("Test 2: Safe dict conversion")
try:
    python_dict = safe_js_to_dict(js_obj)
    log(f"✅ Safe dict conversion: {python_dict}")
except Exception as e:
    log(f"❌ Safe dict conversion failed: {e}")

# Test 3: Symbol.iterator wrapper
log("Test 3: Symbol.iterator wrapper")
try:
    def test_generator():
        yield "item1"
        yield "item2"
    
    wrapper = SymbolIteratorWrapper(test_generator())
    iterator_func = wrapper[Symbol.iterator]
    iterator = iterator_func()
    result = iterator.next()
    log(f"✅ Symbol.iterator wrapper: {result}")
except Exception as e:
    log(f"❌ Symbol.iterator wrapper failed: {e}")

log("All workarounds tested successfully!")
    </script>
</body>
</html>