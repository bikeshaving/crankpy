<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Pipeline Debug - Find js_get_iter Bug Source</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
</head>
<body>
    <div id="test-output"></div>
    
    <mpy-config>
        {
            "files": {
                "./crank/__init__.py": "crank/__init__.py",
                "./crank/dom.py": "crank/dom.py",
                "./crank/typing_stub.py": "crank/typing_stub.py"
            },
            "js_modules": {
                "main": {
                    "https://esm.run/@b9g/crank@0.7.1/crank.js": "crank_core",
                    "https://esm.run/@b9g/crank@0.7.1/dom.js": "crank_dom"
                }
            }
        }
    </mpy-config>
    
    <script type="mpy">
import sys
from js import document, Symbol, Object, console
from pyscript.ffi import create_proxy

output_div = document.getElementById("test-output")

def log_result(message):
    output_div.innerHTML += f"<div>{message}</div>"
    console.log(message)

log_result(f"Python implementation: {sys.implementation.name}")

try:
    from crank import createElement, component, Context, SymbolIteratorWrapper
    from crank.dom import renderer
    
    log_result("üîç Pipeline Debug - Tracing the js_get_iter bug...")
    
    # Step 1: Create a minimal component that uses SymbolIteratorWrapper
    @component  
    def MinimalComponent(ctx):
        log_result("MinimalComponent called")
        
        def test_generator():
            log_result("test_generator started")
            yield createElement("div", None, "Test content")
            log_result("test_generator yielded element")
        
        gen = test_generator()
        wrapped = SymbolIteratorWrapper(gen)
        log_result(f"Created SymbolIteratorWrapper: {type(wrapped)}")
        
        # Test the wrapper works in isolation
        try:
            iterator_func = wrapped[Symbol.iterator]
            iterator = iterator_func()
            first_item = iterator.next()
            log_result(f"‚úÖ SymbolIteratorWrapper isolation test: {first_item}")
        except Exception as e:
            log_result(f"‚ùå SymbolIteratorWrapper isolation failed: {e}")
        
        return wrapped
    
    log_result("=== Step 1: Test component creation ===")
    
    # Test the component function directly
    mock_props = Object.new()
    mock_ctx_js = Object.new()
    mock_ctx_js.props = Object.new()
    mock_ctx = Context(mock_ctx_js)
    
    try:
        log_result("Calling MinimalComponent directly...")
        component_result = MinimalComponent(mock_props, mock_ctx)
        log_result(f"‚úÖ Component call succeeded: {type(component_result)}")
        
        # Test component result iteration
        try:
            comp_iterator_func = component_result[Symbol.iterator]
            comp_iterator = comp_iterator_func()
            comp_item = comp_iterator.next()
            log_result(f"‚úÖ Component result iteration: {comp_item}")
        except Exception as iter_e:
            log_result(f"‚ùå Component result iteration failed: {iter_e}")
            
    except Exception as e:
        log_result(f"‚ùå Component call failed: {e}")
    
    log_result("=== Step 2: Test renderer with minimal setup ===")
    
    # Test renderer interaction
    try:
        log_result("Testing renderer...")
        log_result(f"Renderer type: {type(renderer)}")
        log_result(f"Renderer methods: {dir(renderer)}")
        
        # Create minimal render setup
        container = document.createElement("div")
        document.body.appendChild(container)
        
        log_result("Starting renderer.render...")
        
        # This is where the original error might occur
        try:
            # Try using renderer.render method
            if hasattr(renderer, 'render'):
                render_result = renderer.render(MinimalComponent, container)
                log_result(f"‚úÖ renderer.render succeeded: {render_result}")
            else:
                log_result("No render method found on renderer")
                
        except Exception as render_e:
            log_result(f"‚ùå renderer.render failed: {render_e}")
            
    except Exception as e:
        log_result(f"‚ùå Renderer setup failed: {e}")
    
    log_result("=== Step 3: Debug Crank.js interaction ===")
    
    # Let's see what happens when we pass our SymbolIteratorWrapper to JavaScript
    try:
        from js import eval as js_eval
        
        # Create test wrapper
        def simple_gen():
            yield "test"
        
        simple_wrapper = SymbolIteratorWrapper(simple_gen())
        
        # Test direct JavaScript interaction
        js_test_code = """
        (function(pythonIterable) {
            try {
                // Test 1: Can we get Symbol.iterator?
                const iteratorFunc = pythonIterable[Symbol.iterator];
                console.log("Got iterator function:", typeof iteratorFunc);
                
                // Test 2: Can we call it?
                const iterator = iteratorFunc();
                console.log("Got iterator:", iterator);
                
                // Test 3: Can we call next()?
                const result = iterator.next();
                console.log("Got result:", result);
                
                return { success: true, result: result };
            } catch (e) {
                console.log("JavaScript test failed:", e.message);
                return { success: false, error: e.message };
            }
        })
        """
        
        js_test_func = js_eval(js_test_code)
        js_result = js_test_func(simple_wrapper)
        
        log_result(f"JavaScript interaction test: {dict(js_result)}")
        
        # Test what happens when we use for...of in JavaScript
        js_forof_code = """
        (function(pythonIterable) {
            try {
                const results = [];
                for (const item of pythonIterable) {
                    results.push(item);
                    if (results.length >= 1) break; // Just one iteration
                }
                return { success: true, results: results };
            } catch (e) {
                console.log("JavaScript for...of failed:", e.message);
                return { success: false, error: e.message };
            }
        })
        """
        
        js_forof_func = js_eval(js_forof_code)
        forof_result = js_forof_func(simple_wrapper)
        
        log_result(f"JavaScript for...of test: {dict(forof_result)}")
        
    except Exception as e:
        log_result(f"‚ùå JavaScript interaction test failed: {e}")
    
except Exception as e:
    log_result(f"‚ùå Test setup failed: {e}")

log_result("Pipeline debug completed")
    </script>
</body>
</html>