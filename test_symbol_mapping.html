<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Symbol Mapping Investigation</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
</head>
<body>
    <div id="test-output"></div>
    
    <mpy-config>
        {
            "files": {
                "./crank/__init__.py": "crank/__init__.py",
                "./crank/dom.py": "crank/dom.py",
                "./crank/typing_stub.py": "crank/typing_stub.py"
            },
            "js_modules": {
                "main": {
                    "https://esm.run/@b9g/crank@0.7.1/crank.js": "crank_core",
                    "https://esm.run/@b9g/crank@0.7.1/dom.js": "crank_dom"
                }
            }
        }
    </mpy-config>
    
    <script type="mpy">
import sys
from js import document, Symbol
from pyscript.ffi import create_proxy

output_div = document.getElementById("test-output")

def log_result(message):
    output_div.innerHTML += f"<div>{message}</div>"

log_result(f"Python implementation: {sys.implementation.name}")

try:
    log_result("üîç Investigating Symbol.iterator to __iter__ mapping...")
    
    # Test 1: Can we intercept Symbol access?
    class SymbolMappingGenerator:
        def __init__(self, values):
            self.values = values
        
        def __iter__(self):
            log_result("  SymbolMappingGenerator.__iter__ called!")
            return iter(self.values)
        
        def __aiter__(self):
            log_result("  SymbolMappingGenerator.__aiter__ called!")
            async def async_gen():
                for item in self.values:
                    yield item
            return async_gen()
        
        def __getattribute__(self, name):
            log_result(f"  __getattribute__({name})")
            return super().__getattribute__(name)
        
        def __getattr__(self, name):
            log_result(f"  __getattr__({name})")
            
            # Try to map Symbol.iterator to __iter__
            try:
                if name == str(Symbol.iterator):
                    log_result("  üéØ Symbol.iterator accessed via string!")
                    def iterator_wrapper():
                        return self.__iter__()
                    return create_proxy(iterator_wrapper)
            except:
                pass
            
            raise AttributeError(f"No attribute: {name}")
        
        def __getitem__(self, key):
            log_result(f"  __getitem__({key}, type: {type(key)})")
            
            # Direct Symbol comparison
            if key == Symbol.iterator:
                log_result("  üéØ Symbol.iterator accessed via __getitem__!")
                def iterator_wrapper():
                    return self.__iter__()
                return create_proxy(iterator_wrapper)
            
            # Try async iterator too
            if hasattr(Symbol, 'asyncIterator') and key == Symbol.asyncIterator:
                log_result("  üéØ Symbol.asyncIterator accessed!")
                def async_iterator_wrapper():
                    return self.__aiter__()
                return create_proxy(async_iterator_wrapper)
            
            raise KeyError(f"Key not found: {key}")
    
    # Test 2: Create test object and proxy it
    log_result("=== Creating symbol mapping test object ===")
    test_values = ["hello", "world", "symbol", "mapping"]
    mapping_gen = SymbolMappingGenerator(test_values)
    
    log_result("Testing direct Python iteration:")
    for item in mapping_gen:
        log_result(f"  Python iteration: {item}")
        break  # Just test first item
    
    # Test 3: Test proxy behavior
    log_result("=== Testing proxy behavior ===")
    proxied_gen = create_proxy(mapping_gen)
    log_result(f"Proxied object type: {type(proxied_gen)}")
    
    # Test Symbol access
    log_result("Testing Symbol.iterator access:")
    try:
        iterator_symbol = Symbol.iterator
        log_result(f"Symbol.iterator: {iterator_symbol}")
        
        # Try different access methods
        log_result("Method 1: Direct symbol access")
        try:
            iter_func = proxied_gen[iterator_symbol]
            log_result(f"‚úÖ Got iterator function: {type(iter_func)}")
        except Exception as e:
            log_result(f"‚ùå Direct access failed: {e}")
        
        log_result("Method 2: String representation")
        try:
            iter_func = getattr(proxied_gen, str(iterator_symbol))
            log_result(f"‚úÖ String access worked: {type(iter_func)}")
        except Exception as e:
            log_result(f"‚ùå String access failed: {e}")
            
    except Exception as e:
        log_result(f"‚ùå Symbol access failed: {e}")
    
    # Test 4: Direct JavaScript iteration test
    log_result("=== Testing direct JavaScript iteration ===")
    
    # Create a pure Python iterator that might work better
    class SimpleIterator:
        def __init__(self, generator):
            self.generator = generator
            
        def __getitem__(self, key):
            log_result(f"SimpleIterator.__getitem__({key})")
            
            if key == Symbol.iterator:
                log_result("  üéØ SimpleIterator: Symbol.iterator accessed!")
                
                def create_js_iterator():
                    # Create a JavaScript-compatible iterator
                    class JSIterator:
                        def __init__(self, py_iter):
                            self.py_iter = py_iter
                        
                        def next(self):
                            try:
                                value = next(self.py_iter)
                                return {"value": value, "done": False}
                            except StopIteration:
                                return {"value": None, "done": True}
                    
                    return JSIterator(iter(self.generator))
                
                return create_proxy(create_js_iterator)
            
            raise KeyError(f"Key not found: {key}")
    
    log_result("Creating SimpleIterator...")
    simple_iter = SimpleIterator(test_values)
    
    # Test if this approach works
    log_result("Testing SimpleIterator Symbol.iterator access:")
    try:
        iterator_func = simple_iter[Symbol.iterator]
        log_result(f"‚úÖ SimpleIterator Symbol.iterator: {type(iterator_func)}")
        
        # Test creating iterator
        js_iterator = iterator_func()
        log_result(f"‚úÖ Created JS iterator: {type(js_iterator)}")
        
        # Test next() calls
        result1 = js_iterator.next()
        log_result(f"First next(): {result1}")
        
        result2 = js_iterator.next()
        log_result(f"Second next(): {result2}")
        
    except Exception as e:
        log_result(f"‚ùå SimpleIterator test failed: {e}")
        import traceback
        log_result(f"Traceback: {traceback.format_exc()}")
        
except Exception as e:
    log_result(f"‚ùå Test failed: {e}")
    import traceback
    log_result(f"Traceback: {traceback.format_exc()}")

log_result("Symbol mapping investigation completed")
    </script>
</body>
</html>