<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Direct Approach Test</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
</head>
<body>
    <div id="test-output"></div>
    
    <mpy-config>
        {
            "files": {
                "./crank/__init__.py": "crank/__init__.py",
                "./crank/typing_stub.py": "crank/typing_stub.py"
            }
        }
    </mpy-config>
    
    <script type="mpy">
import sys
from js import document, window, Array, Symbol
from pyscript.ffi import create_proxy, to_js

output_div = document.getElementById("test-output")

def log_result(message):
    output_div.innerHTML += f"<div>{message}</div>"

log_result(f"Python implementation: {sys.implementation.name}")

try:
    # Try a completely different approach - use Array directly
    log_result("Approach 1: Using JavaScript Array...")
    
    def test_generator():
        yield "item1"
        yield "item2"
        yield "item3"
    
    # Convert generator to list and then to JS Array
    gen_items = list(test_generator())
    js_array = to_js(gen_items)
    
    log_result(f"JS Array type: {type(js_array)}")
    
    # Test if Array has Symbol.iterator
    iterator_symbol = Symbol.iterator
    has_iterator = iterator_symbol in js_array
    log_result(f"Array has Symbol.iterator: {has_iterator}")
    
    if has_iterator:
        log_result("✅ Array approach works!")
        
        # Test iteration
        iterator = js_array[iterator_symbol]()
        result1 = iterator.next()
        log_result(f"Array iteration 1: {result1.value}, done: {result1.done}")
    
    # Try approach 2: Return Array directly from component
    log_result("Approach 2: Component returning Array...")
    
    from pyscript.ffi import create_proxy
    
    def component_wrapper(props, ctx):
        """Test component that returns Array directly"""
        log_result("Component wrapper called!")
        
        # Simulate what a generator component would yield
        items = ["Hello", "from", "MicroPython"]
        return to_js(items)
    
    # Test calling the component
    from js import Object
    mock_ctx = Object.new()
    mock_props = Object.new()
    
    result = component_wrapper(mock_props, mock_ctx)
    log_result(f"Component result type: {type(result)}")
    
    # Check if result has Symbol.iterator
    result_has_iterator = iterator_symbol in result if result else False
    log_result(f"Component result has Symbol.iterator: {result_has_iterator}")
    
    if result_has_iterator:
        log_result("✅ Component Array approach works!")
        
        # Test if this would work with Crank.js style iteration
        iterator = result[iterator_symbol]()
        all_values = []
        while True:
            next_result = iterator.next()
            if next_result.done:
                break
            all_values.append(next_result.value)
        
        log_result(f"All values: {all_values}")
    
    # Try approach 3: Generator wrapper that yields once
    log_result("Approach 3: Single-yield generator...")
    
    def single_yield_wrapper(items):
        """Wrap items in a generator that yields once"""
        def wrapper_generator():
            for item in items:
                yield item
        
        gen = wrapper_generator()
        # Convert to list then to JS Array
        return to_js(list(gen))
    
    wrapped_result = single_yield_wrapper(["test1", "test2"])
    log_result(f"Wrapped result has Symbol.iterator: {iterator_symbol in wrapped_result}")
        
except Exception as e:
    log_result(f"❌ Test failed: {e}")

log_result("Direct approach test completed")
    </script>
</body>
</html>