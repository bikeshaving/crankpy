<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>JsProxy Monkey Patch Test</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
</head>
<body>
    <div id="test-output"></div>
    
    <mpy-config>
        {
            "files": {
                "./crank/__init__.py": "crank/__init__.py",
                "./crank/dom.py": "crank/dom.py",
                "./crank/typing_stub.py": "crank/typing_stub.py"
            },
            "js_modules": {
                "main": {
                    "https://esm.run/@b9g/crank@0.7.1/crank.js": "crank_core",
                    "https://esm.run/@b9g/crank@0.7.1/dom.js": "crank_dom"
                }
            }
        }
    </mpy-config>
    
    <script type="mpy">
import sys
from js import document, Symbol
from pyscript.ffi import create_proxy

output_div = document.getElementById("test-output")

def log_result(message):
    output_div.innerHTML += f"<div>{message}</div>"

log_result(f"Python implementation: {sys.implementation.name}")

try:
    log_result("üêí Monkey patching JsProxy for Symbol.iterator support...")
    
    # First, let's understand what we're working with
    def test_generator():
        yield "test1"
        yield "test2"
        yield "test3"
    
    gen = test_generator()
    proxied_gen = create_proxy(gen)
    
    log_result(f"Generator type: {type(gen)}")
    log_result(f"Proxied generator type: {type(proxied_gen)}")
    log_result(f"Proxied generator class: {proxied_gen.__class__}")
    
    # Get the JsProxy class for monkey patching
    JsProxyClass = type(proxied_gen)
    log_result(f"JsProxy class: {JsProxyClass}")
    
    # Store Symbol.iterator reference
    iterator_symbol = Symbol.iterator
    log_result(f"Iterator symbol: {iterator_symbol}")
    
    # Check if JsProxy already has __getitem__
    has_getitem = hasattr(JsProxyClass, '__getitem__')
    log_result(f"JsProxy has __getitem__: {has_getitem}")
    
    # Store original __getitem__ if it exists
    original_getitem = getattr(JsProxyClass, '__getitem__', None)
    log_result(f"Original __getitem__: {original_getitem}")
    
    # Create our enhanced __getitem__
    def enhanced_getitem(self, key):
        log_result(f"Enhanced __getitem__ called with: {key} (type: {type(key)})")
        
        # Check for Symbol.iterator
        if key == iterator_symbol:
            log_result("üéØ Symbol.iterator detected in monkey patch!")
            
            # Check if the wrapped Python object has __iter__
            if hasattr(self, '_wrapped_object'):
                wrapped = self._wrapped_object
                log_result(f"Found wrapped object: {type(wrapped)}")
            else:
                # Try to get the underlying Python object
                # This might be implementation-specific
                wrapped = None
                for attr in ['_pyobj', '_py_object', '__wrapped__']:
                    if hasattr(self, attr):
                        wrapped = getattr(self, attr)
                        log_result(f"Found Python object via {attr}: {type(wrapped)}")
                        break
                
                if wrapped is None:
                    log_result("Could not find wrapped Python object")
                    # Fallback: assume self is the generator/iterable
                    wrapped = self
            
            # Check if it's iterable
            if hasattr(wrapped, '__iter__'):
                log_result("‚úÖ Wrapped object is iterable!")
                
                def js_iterator_function():
                    log_result("Creating JavaScript iterator from Python iterable")
                    
                    class JSIterator:
                        def __init__(self, python_iterable):
                            log_result(f"JSIterator wrapping: {type(python_iterable)}")
                            self.python_iterator = iter(python_iterable)
                        
                        def next(self):
                            try:
                                value = next(self.python_iterator)
                                log_result(f"JSIterator.next() -> {value}")
                                return {"value": value, "done": False}
                            except StopIteration:
                                log_result("JSIterator.next() -> DONE")
                                return {"value": None, "done": True}
                    
                    return JSIterator(wrapped)
                
                return create_proxy(js_iterator_function)
            else:
                log_result("‚ùå Wrapped object is not iterable")
        
        # Fallback to original behavior
        if original_getitem:
            log_result("Falling back to original __getitem__")
            return original_getitem(self, key)
        else:
            log_result("No original __getitem__, raising KeyError")
            raise KeyError(f"Key not found: {key}")
    
    # Apply the monkey patch
    log_result("=== Applying monkey patch ===")
    JsProxyClass.__getitem__ = enhanced_getitem
    log_result("‚úÖ Monkey patch applied!")
    
    # Test 1: Test our patched JsProxy
    log_result("=== Testing patched JsProxy ===")
    
    try:
        # Test Symbol.iterator access
        iterator_func = proxied_gen[iterator_symbol]
        log_result(f"‚úÖ Got iterator function: {type(iterator_func)}")
        
        # Test iterator creation
        js_iterator = iterator_func()
        log_result(f"‚úÖ Created JS iterator: {type(js_iterator)}")
        
        # Test iteration
        result1 = js_iterator.next()
        log_result(f"First result: {result1}")
        
        result2 = js_iterator.next()
        log_result(f"Second result: {result2}")
        
        result3 = js_iterator.next()
        log_result(f"Third result: {result3}")
        
        result4 = js_iterator.next()
        log_result(f"Fourth result (should be done): {result4}")
        
    except Exception as e:
        log_result(f"‚ùå Patched JsProxy test failed: {e}")
    
    # Test 2: Test with a new generator to make sure patch works globally
    log_result("=== Testing new generator ===")
    
    def fibonacci_generator():
        a, b = 0, 1
        for i in range(5):
            yield a
            a, b = b, a + b
    
    fib_gen = fibonacci_generator()
    proxied_fib = create_proxy(fib_gen)
    
    try:
        fib_iterator_func = proxied_fib[iterator_symbol]
        fib_iterator = fib_iterator_func()
        
        fib_results = []
        for i in range(6):  # One more than generator produces
            result = fib_iterator.next()
            fib_results.append(result)
            if result["done"]:
                break
        
        log_result(f"‚úÖ Fibonacci results: {fib_results}")
        
    except Exception as e:
        log_result(f"‚ùå Fibonacci test failed: {e}")
    
    # Test 3: Test if this works with actual Crank component
    log_result("=== Testing with Crank component ===")
    
    try:
        from crank import h, component, createElement
        from crank.dom import renderer
        
        @component
        def MonkeyPatchedComponent(ctx):
            log_result("MonkeyPatchedComponent called")
            
            def content_generator():
                yield createElement("div", None, "Patched item 1")
                yield createElement("div", None, "Patched item 2")
                yield createElement("div", None, "Patched item 3")
            
            # Return the generator - it should now work with Symbol.iterator!
            log_result("Returning generator from component")
            return content_generator()
        
        log_result("Creating component element...")
        component_element = createElement(MonkeyPatchedComponent, None)
        
        # This should work now that JsProxy supports Symbol.iterator!
        log_result("Attempting to render...")
        render_result = renderer.render(component_element, document.getElementById("test-output"))
        
        log_result("üéâ SUCCESS: Monkey patched JsProxy works with Crank!")
        
    except Exception as e:
        log_result(f"‚ùå Crank component test failed: {e}")
        
except Exception as e:
    log_result(f"‚ùå Monkey patch test failed: {e}")

log_result("JsProxy monkey patch test completed")
    </script>
</body>
</html>