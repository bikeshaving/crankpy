<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Window Approach Test</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2025.8.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2025.8.1/core.js"></script>
</head>
<body>
    <div id="test-output"></div>
    
    <mpy-config>
        {
            "files": {
                "./crank/__init__.py": "crank/__init__.py",
                "./crank/typing_stub.py": "crank/typing_stub.py"
            }
        }
    </mpy-config>
    
    <script type="mpy">
import sys
from js import document, Symbol, Object, eval as js_eval, window
from pyscript.ffi import create_proxy, to_js

output_div = document.getElementById("test-output")

def log_result(message):
    output_div.innerHTML += f"<div>{message}</div>"

log_result(f"Python implementation: {sys.implementation.name}")

try:
    def simple_generator():
        yield "hello"
        yield "world"
        yield "from"
        yield "micropython"
    
    def make_iterator():
        gen = simple_generator()
        
        def next_func():
            try:
                value = next(gen)
                return to_js({'value': value, 'done': False})
            except StopIteration:
                return to_js({'value': None, 'done': True})
        
        iterator = Object.new()
        iterator.next = create_proxy(next_func)
        return iterator
    
    # Store the iterator function on the global window
    window.pythonIteratorFactory = create_proxy(make_iterator)
    log_result("✅ Iterator factory stored on window")
    
    # Use JavaScript eval to create an object with Symbol.iterator
    js_code = """
    (function() {
        const obj = {};
        obj[Symbol.iterator] = window.pythonIteratorFactory;
        return obj;
    })()
    """
    
    iterable = js_eval(js_code)
    log_result(f"✅ Iterable created: {type(iterable)}")
    
    # Test the iterable by trying to use it in JavaScript
    test_code = """
    (function(iterable) {
        try {
            const iterator = iterable[Symbol.iterator]();
            const results = [];
            let result = iterator.next();
            while (!result.done) {
                results.push(result.value);
                result = iterator.next();
            }
            return results;
        } catch (e) {
            return ['Error: ' + e.message];
        }
    })
    """
    
    test_func = js_eval(test_code)
    results = test_func(iterable)
    
    log_result(f"✅ Iteration results: {results}")
    
    # Now test if this would work with Crank.js by simulating iteration
    log_result("Testing Crank.js-style iteration...")
    
    # Simulate what Crank.js does
    crank_test_code = """
    (function(iterable) {
        try {
            // This is what Crank.js does internally
            const iterator = iterable[Symbol.iterator]();
            return {success: true, iterator: iterator};
        } catch (e) {
            return {success: false, error: e.message};
        }
    })
    """
    
    crank_test_func = js_eval(crank_test_code)
    crank_result = crank_test_func(iterable)
    
    if crank_result.success:
        log_result("✅ Crank.js-style iteration successful!")
    else:
        log_result(f"❌ Crank.js-style iteration failed: {crank_result.error}")
        
except Exception as e:
    log_result(f"❌ Test failed: {e}")
    log_result(f"Error type: {type(e).__name__}")

log_result("Window approach test completed")
    </script>
</body>
</html>